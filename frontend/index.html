<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A tool to analyze and redact text by highlighting important words and phrases.">
    <meta name="keywords" content="redact, text analysis, privacy, redaction tool, text highlighter">
    <meta name="author" content="Redac't">
    <meta name="robots" content="index, follow">
    <title>Redac’t</title>
    <style>
        @font-face {
            font-family: 'Source Sans Pro';
            src: url('static/fonts/SourceSansPro-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Source Sans Pro';
            src: url('static/fonts/SourceSansPro-Bold.ttf') format('truetype');
            font-weight: bold;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Source Code Pro';
            src: url('static/fonts/SourceCodePro-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Source Code Pro';
            src: url('static/fonts/SourceCodePro-Bold.ttf') format('truetype');
            font-weight: bold;
            font-style: normal;
            font-display: swap;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            font-family: 'Source Sans Pro', Arial, sans-serif;
        }

        h1 {
            font-size: 24px;
        }

        header {
            background-color: #14315B;
            color: white;
            padding: 10px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        main {
            flex: 1;
            display: flex;
            gap: 0;
            overflow-y: auto;
        }

        #editor-wrapper {
            position: relative;
            flex: 1;
            height: 100%;
            overflow-y: auto;
            background-color: white;
        }

        .container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100%;
            padding: 15px;
            margin: 0;
            font-family: 'Source Code Pro', monospace;
            font-size: 16px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            border: none;
        }

        #editor {
            z-index: 2;
            color: black;
            background: transparent;
            /* Wichtig: Man sieht den Highlighter durch */
            caret-color: black;
            /* Cursor sichtbar halten */
            outline: none;
        }

        #highlighter {
            z-index: 1;
            color: transparent;
            user-select: none;
            pointer-events: none;
        }

        #highlighter span {
            color: transparent;
            border-radius: 2px;
            transition: background-color 0.3s ease, opacity 0.3s ease;
        }

        .controls {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 15px;
        }

        footer {
            font-size: smaller;
            background-color: #14315B;
            color: white;
            padding: 10px;
            text-align: center;
        }
    </style>
</head>

<body>
    <header>
        <h1>Redac’t</h1>
        <div class="controls">
            <label for="single-level">Word</label>
            <input type="range" id="single-level" min="0" max="4" step="1" list="steplist">
            <label for="phrase-level">Phrase</label>
            <input type="range" id="phrase-level" min="0" max="4" step="1" list="steplist">
            <datalist id="steplist">
                <option value="0"></option>
                <option value="40"></option>
                <option value="70"></option>
                <option value="90"></option>
                <option value="100"></option>
            </datalist>
            <button id="download-redacted" title="Download Redacted Text"
                style="background: none; border: none; cursor: pointer; color: white; vertical-align: middle; padding: 0 10px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"
                    stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
        </div>
    </header>

    <main>
        <div id="editor-wrapper">
            <div id="highlighter" class="container"></div>
            <div id="editor" class="container" contenteditable="true" spellcheck="false"></div>
        </div>
    </main>

    <footer>
        <p>&copy; 2026 Redac’t. All rights reserved.</p>
    </footer>
</body>

<script>
    (function (window) {
        // container for DOM elements of interest
        const el = {};
        const API_VERSION = "v1";
        const ANALYZE_ENDPOINT = `/api/${API_VERSION}/analyze`;
        const REDACT_ENDPOINT = `/api/${API_VERSION}/redact`;

        let analysisTimeout;

        function escapeHtml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        async function downloadRedactedText() {
            const editor = document.getElementById('editor');
            const text = editor.innerText;
            if (!text.trim())
                return;
            const datalistOptions = Array.from(document.querySelectorAll('#steplist option')).map(opt => parseInt(opt.value));
            const phraseValue = datalistOptions[document.getElementById('phrase-level').value];
            const singleValue = datalistOptions[document.getElementById('single-level').value];
            const modes = [];
            if (phraseValue > 0)
                modes.push({ type: 'phrase', level: phraseValue });
            if (singleValue > 0)
                modes.push({ type: 'single', level: singleValue });
            try {
                const response = await fetch(REDACT_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: text,
                        modes: modes
                    })
                });
                const data = await response.json();
                const blob = new Blob([data.redacted_text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                a.href = url;
                a.download = `redacted_final_${timestamp}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

            }
            catch (error) {
                console.error("Download failed:", error);
                alert("Fehler beim Erstellen der geschwärzten Datei.");
            }
        }

        function analyzeText() {
            if (!el.editor || el.editor.innerText.length === 0)
                return;
            const modes = [];
            const datalistOptions = Array.from(document.querySelectorAll('#steplist option')).map(opt => parseInt(opt.value));
            const phraseLevel = parseInt(document.getElementById('phrase-level').value);
            const phraseValue = datalistOptions[phraseLevel];
            if (phraseValue > 0) {
                modes.push({
                    type: 'phrase',
                    level: phraseValue,
                });
            }
            const singleLevel = parseInt(document.getElementById('single-level').value);
            const singleValue = datalistOptions[singleLevel];
            if (singleValue > 0) {
                modes.push({
                    type: 'single',
                    level: singleValue,
                });
            }
            const originalText = el.editor.innerText.replace(/\r\n/g, '\n');
            fetch(ANALYZE_ENDPOINT, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    text: originalText,
                    modes: modes
                })
            })
                .then(response => response.json())
                .then(data => {
                    let html = "";
                    let cursor = 0;
                    for (const [start, end, importance] of data.analysis) {
                        if (start > cursor) {
                            html += escapeHtml(originalText.slice(cursor, start));
                        }
                        const r = Math.round(255 * importance);
                        const g = Math.round(255 * (1 - importance));
                        html += `<span style="background-color: rgba(${r}, ${g}, 0, 0.3);">${escapeHtml(originalText.slice(start, end))}</span>`;
                        cursor = end;
                    }
                    if (cursor < originalText.length) {
                        html += escapeHtml(originalText.slice(cursor));
                    }

                    el.highlighter.innerHTML = html.replace(/\n/g, "<br>");
                })
                .catch(error => console.error("Error:", error));
        }

        function onInput() {
            if (!analysisTimeout) {
                analyzeText();
            }
            clearTimeout(analysisTimeout);
            analysisTimeout = setTimeout(() => {
                analyzeText();
            }, 400);
        }

        function onSliderChange() {
            analyzeText();
        }

        function setup() {
            el.highlighter = document.getElementById('highlighter');
            el.editor = document.getElementById('editor');
            el.editor.addEventListener('input', onInput);
            el.editor.addEventListener('paste', e => {
                e.preventDefault();
                const text = (e.originalEvent || e).clipboardData.getData('text/plain');
                document.execCommand('insertText', false, text);
            });
            el.editor.addEventListener('scroll', () => {
                el.highlighter.scrollTop = el.editor.scrollTop;
            });
            el.phraseSlider = document.getElementById('phrase-level');
            el.phraseSlider.addEventListener('input', onSliderChange);
            el.singleSlider = document.getElementById('single-level');
            el.singleSlider.addEventListener('input', onSliderChange);
            document.getElementById('download-redacted').addEventListener('click', downloadRedactedText);
            analyzeText();
        }

        document.addEventListener('DOMContentLoaded', setup);
    })(window);
</script>

</html>